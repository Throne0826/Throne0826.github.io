<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Throne</title>
    <link>https://lifexoryoung.com.cn/</link>
    
    <atom:link href="https://lifexoryoung.com.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>读一些无用的书，做一些无用的事，花一些无用的时间，都是为了在一切已知之外，保留一个超越自己的机会，人生中一些很了不起的变化，就是来自这种时刻。——梁文道</description>
    <pubDate>Mon, 10 Jun 2024 13:35:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>强连通分量(scc缩点/tarjan)</title>
      <link>https://lifexoryoung.com.cn/2024/06/10/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-scc%E7%BC%A9%E7%82%B9-tarjan/</link>
      <guid>https://lifexoryoung.com.cn/2024/06/10/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-scc%E7%BC%A9%E7%82%B9-tarjan/</guid>
      <pubDate>Mon, 10 Jun 2024 11:46:24 GMT</pubDate>
      
      <description>&lt;p&gt;学习了一下强连通分量，整理一下：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>学习了一下强连通分量，整理一下：</p><span id="more"></span><p>强连通分量的概念：任意两点之间能相互到达。</p><p>缩点简单来讲就是缩环成点，把强连通分量用一个点来维护，形成$DAG$有向无环图。</p><p>缩点方式有三种这里只说一下$tarjan$。</p><h3 id="tarjan-求-SCC-缩点：时间复杂度-O-n-m"><a href="#tarjan-求-SCC-缩点：时间复杂度-O-n-m" class="headerlink" title="$tarjan$求$SCC$缩点：时间复杂度$O(n+m)$"></a>$tarjan$求$SCC$缩点：时间复杂度$O(n+m)$</h3><p>单纯判断是否有环一般可以用$dfs$，那么在搜索过程中我们对点只有三种情况：</p><p>1.该点没有搜索过。</p><p>2.该点有搜索过，但是不是我们上一个遍历的点的祖宗节点。</p><p>3.该点有搜索过，是我们上一个遍历节点的祖宗节点。</p><p>下图描述了三种情况：黑色边为$1$，绿色边为$2$，蓝色边为$3$。</p><img src="/2024/06/10/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-scc%E7%BC%A9%E7%82%B9-tarjan/image-20240610201027622.webp" class="" title="image-1"><p>显然，只有第三种边能成环，成环的这些为强连通分量，其他的单独一个点作为强连通分量（自己本身就能到达自己），所以上图的强连通分量为（{1}，{2，3}，{4}，{5}）四个。</p><p>但是实际情况可能有很多个环嵌套，所以我们不能判断当前为环后，直接进行缩点，应该所有该子节点环判断完后，一块缩点。</p><p>为了解决这种问题，我们引入一个 $dfn$（时间戳）来记录我们第一次到达每个节点的顺序，一个 $low$（当前节点所接触到的最早的时间戳节点，初始为当前节点的 $dfn$ 值），在回溯的过程中对当前节点$low$与其子节点取$min$值来实现维护最大强连通分量集合，一个栈存我们 $dfs$ 过程的节点。</p><p>因为 $dfn==low$ 的时候说明此节点为一个强连通分量的最早结点，那么我们可以开始从栈头开始 $pop$，直到栈头等于当前节点，那么取出的节点即为我们所维护的一个强连通分量集合。</p><p>具体细节可以看代码：</p><pre><code class="lang-c++">int dfn[N],low[N],cnt,sz[N],scc[N],sc;stack&lt;int&gt;st;vector&lt;int&gt;e[N];bool vis[N];void tarjan(int u)&#123;    dfn[u]=low[u]=++cnt;    st.push(u),vis[u]=true;    for(auto &amp;to:e[u])&#123;        if(!dfn[to])&#123;            tarjan(to);            low[u]=min(low[u],low[to]);        &#125;        else if(vis[to])&#123;            low[u]=min(low[u],dfn[to]);        &#125;    &#125;    if(dfn[u]==low[u])&#123;        sc++;        while(st.top()!=u)&#123;            sz[sc]+=w[st.top()];            scc[st.top()]=sc;            vis[st.top()]=0;            st.pop();        &#125;        sz[sc]+=w[st.top()];        scc[st.top()]=sc;        vis[st.top()]=0;        st.pop();    &#125;&#125;</code></pre><h3 id="例题：P3387-【模板】缩点-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#例题：P3387-【模板】缩点-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="例题：P3387 【模板】缩点 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>例题：<a href="https://www.luogu.com.cn/problem/P3387">P3387 【模板】缩点 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p><p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个正整数 $n,m$</p><p>第二行 $n$ 个整数，其中第 $i$ 个数 $a_i$ 表示点 $i$ 的点权。</p><p>第三至 $m+2$ 行，每行两个整数 $u,v$，表示一条 $u\rightarrow v$ 的有向边。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，最大的点权之和。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h4><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><pre><code>2 21 11 22 1</code></pre><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><pre><code>2</code></pre><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，$0\le a_i\le 10^3$。</p><p>思路：</p><p>因为是有向图，所以可能存在有环的情况，因为每个点可以走多次，所以只要是路径上有环，我们全部取掉为最优。所以直接用$scc$缩点，重新建图，把图变为有向无环图$（DAG）$，新缩成的点的权值为全部点的点权和。那么该题就变成了，给你一个$DAG$，和每个点的点权，求点权最长路径。直接在新图的拓扑序中dp维护权值$max$即可。</p><pre><code class="lang-c++">int dfn[N],low[N],cnt,sz[N],scc[N],sc,d[N],dp[N],ans,w[N];stack&lt;int&gt;st;vector&lt;int&gt;e[N],ex[N];bool vis[N];queue&lt;int&gt;q;void tarjan(int u)&#123;    dfn[u]=low[u]=++cnt;    st.push(u),vis[u]=true;    for(auto &amp;to:e[u])&#123;        if(!dfn[to])&#123;            tarjan(to);            low[u]=min(low[u],low[to]);        &#125;        else if(vis[to])&#123;            low[u]=min(low[u],dfn[to]);        &#125;    &#125;    if(dfn[u]==low[u])&#123;        sc++;        while(st.top()!=u)&#123;            sz[sc]+=w[st.top()];            scc[st.top()]=sc;            vis[st.top()]=0;            st.pop();        &#125;        sz[sc]+=w[st.top()];        scc[st.top()]=sc;        vis[st.top()]=0;        st.pop();    &#125;&#125;void topu()&#123;    for(int i=1;i&lt;=sc;i++)if(!d[i])q.push(i),ans=max(ans,(dp[i]=sz[i]));    while(q.size())&#123;        int ver=q.front();        q.pop();        for(auto &amp;to:ex[ver])&#123;            d[to]--;            dp[to]=max(dp[to],dp[ver]+sz[to]);            ans=max(ans,dp[to]);            if(!d[to])q.push(to);        &#125;    &#125;&#125;void solve()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];    for(int i=1;i&lt;=m;i++)&#123;        int u,v;cin&gt;&gt;u&gt;&gt;v;        e[u].pb(v);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(!dfn[i])tarjan(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        int u=scc[i];        for(auto &amp;to:e[i])&#123;            int v=scc[to];            if(u==v)continue;            ex[u].pb(v);            d[v]++;        &#125;    &#125;    topu();    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;&#125;</code></pre><h3 id="P2812-校园网络【-USACO-Network-of-Schools加强版】-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2812-校园网络【-USACO-Network-of-Schools加强版】-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2812 校园网络【[USACO]Network of Schools加强版】 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P2812">P2812 校园网络【[USACO]Network of Schools加强版】 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h4><p>浙江省的几所 OI 强校的神犇发明了一种人工智能，可以 AC 任何题目，所以他们决定建立一个网络来共享这个软件。但是由于他们脑力劳动过多导致全身无力身体被♂掏♂空，他们来找你帮助他们。</p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>共有 $n$ 所学校 $(1 \leq n \leq 10000)$ 已知他们实现设计好的网络共 $m$ 条线路，为了保证高速，网络是单向的。现在请你告诉他们至少选几所学校作为共享软件的母机，能使每所学校都可以用上。再告诉他们至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个正整数 $n$。</p><p>接下来 $n$ 行每行有若干个整数，用空格隔开。</p><p>第 $i+1$ 行，每行输入若干个非零整数 $x$，表示从 $i$ 到 $x$ 有一条线路。以 $0$ 作为结束标志。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行一个整数，表示至少选几所学校作为共享软件的母机，能使每所学校都可以用上。</p><p>第二行一个整数，表示至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。</p><h4 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h4><h4 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><pre><code>52 04 05 01 00</code></pre><h4 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><pre><code>22</code></pre><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>实际上，$1 \leq n \leq 10000$，$1\le $ 边数 $\le 50000$。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>依旧是$scc$缩点形成$DAG$，对于第一个问题：入度为零的点个数即为最少学校，因为入度为零的点为每一个联通图的初始节点。对于第二个问题：$max$(入度为零的点,出度为零的点）即为答案，因为要整体成强连通分量只能把所有把现有的边入度和出度都为零，因为连接一条边是入度出度都++，所以输出$max$入度或者出度即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">int dfn[N],low[N],cnt,sz[N],scc[N],sc,d[N],ud[N];stack&lt;int&gt;st;vector&lt;int&gt;e[N],ex[N];bool vis[N];queue&lt;int&gt;q;void tarjan(int u)&#123;    dfn[u]=low[u]=++cnt;    st.push(u),vis[u]=true;    for(auto &amp;to:e[u])&#123;        if(!dfn[to])&#123;            tarjan(to);            low[u]=min(low[u],low[to]);        &#125;        else if(vis[to])&#123;            low[u]=min(low[u],dfn[to]);        &#125;    &#125;    if(dfn[u]==low[u])&#123;        sc++;        while(st.top()!=u)&#123;            scc[st.top()]=sc;            vis[st.top()]=0;            st.pop();        &#125;        scc[st.top()]=sc;        vis[st.top()]=0;        st.pop();    &#125;&#125;void solve()&#123;    int n;cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int x;        while(cin&gt;&gt;x,x)&#123;            e[i].pb(x);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)    if(!dfn[i])tarjan(i);    int ans1=0,ans2=0;    for(int i=1;i&lt;=n;i++)&#123;        int u=scc[i];        for(auto &amp;to:e[i])&#123;            int v=scc[to];            if(u==v)continue;            d[v]++,ud[u]++;        &#125;    &#125;    for(int i=1;i&lt;=sc;i++)    &#123;        if(!d[i])ans1++;        if(!ud[i])ans2++;    &#125;    cout&lt;&lt;ans1&lt;&lt;&quot;\n&quot;;    if(sc==1)    cout&lt;&lt;0&lt;&lt;&quot;\n&quot;;    else cout&lt;&lt;max(ans1,ans2)&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/dfs/">dfs</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">强连通分量</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/tarjan/">tarjan</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%8B%93%E6%89%91/">拓扑</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/06/10/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-scc%E7%BC%A9%E7%82%B9-tarjan/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>lca与树上（路径交、并，直径）问题</title>
      <link>https://lifexoryoung.com.cn/2024/05/27/lca%E4%B8%8E%E6%A0%91%E4%B8%8A%EF%BC%88%E8%B7%AF%E5%BE%84%E4%BA%A4%E3%80%81%E5%B9%B6%EF%BC%8C%E7%9B%B4%E5%BE%84%EF%BC%89%E9%97%AE%E9%A2%98/</link>
      <guid>https://lifexoryoung.com.cn/2024/05/27/lca%E4%B8%8E%E6%A0%91%E4%B8%8A%EF%BC%88%E8%B7%AF%E5%BE%84%E4%BA%A4%E3%80%81%E5%B9%B6%EF%BC%8C%E7%9B%B4%E5%BE%84%EF%BC%89%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Mon, 27 May 2024 07:56:00 GMT</pubDate>
      
      <description>&lt;p&gt;最近的一些比赛中经常用到树上$lca$的常见模型，整理一下：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近的一些比赛中经常用到树上$lca$的常见模型，整理一下：</p><span id="more"></span><p>首先整理一下$LCA$的四种求法：</p><p>1.倍增$LCA$：预处理$O(nlogn)$  单次查询$O(logn)$</p><p>通过$bfs$预处理节点深度和$st$表倍增处理祖宗节点，在查询的时候用倍增先将两点跳到统一深度，再找同祖宗节点的最深节点</p><pre><code class="lang-c++">int n,depth[N],f[N][19];vector&lt;int&gt;e[N];void bfs(int root)&#123;    memset(depth,0x3f,sizeof depth);    depth[0]=0,depth[root]=1;//0为st表的哨兵    queue&lt;int&gt;q;    q.push(root);    while(q.size())&#123;        int ver=q.front();        q.pop();        for(auto &amp;to:e[ver])&#123;            if(depth[to]&gt;depth[ver]+1)&#123;                depth[to]=depth[ver]+1;                f[to][0]=ver;                for(int i=1;i&lt;=18;i++)                f[to][i]=f[f[to][i-1]][i-1];            &#125;        &#125;    &#125;&#125;int lca(int a,int b)&#123;    if(depth[a]&lt;depth[b])swap(a,b);    for(int i=18;i&gt;=0;i--)&#123;        if(depth[f[a][i]]&lt;=depth[b])        a=f[a][i];    &#125;    if(a==b)return a;    for(int i=18;i&gt;=0;i--)&#123;        if(f[a][i]!=f[b][i])        a=f[a][i],b=f[b][i];    &#125;    return f[a][0];&#125;</code></pre><p>2.$Tarjan$离线$LCA$: 总体时间复杂度$O(n+q)$ ，$n$为节点 $q$为查询次数</p><p>暂定</p><p>3.在线$RMQLCA$：预处理$O(nlogn)$ 单次查询$O(1)$</p><p>通过$dfs$处理欧拉序及其深度，并保存每个节点第一次出现位置，通过$st$表维护区间深度最小值即可</p><pre><code class="lang-c++">int n,q,root,depth[N&lt;&lt;1],f[N&lt;&lt;1][19],se[N&lt;&lt;1],tot,Log[N&lt;&lt;1],id[N];vector&lt;int&gt;e[N];void dfs(int u,int d,int fa)&#123;    se[++tot]=u;    id[u]=tot;    depth[tot]=d;    for(auto &amp;to:e[u])&#123;        if(to==fa)continue;        dfs(to,d+1,u);        se[++tot]=u;        depth[tot]=d;    &#125;&#125;int lca(int l,int r)&#123;    int k=Log[r-l+1];    return depth[f[l][k]]&lt;depth[f[r-(1&lt;&lt;k)+1][k]]?    se[f[l][k]]:se[f[r-(1&lt;&lt;k)+1][k]];&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;q&gt;&gt;root;    for(int i=1;i&lt;n;i++)&#123;        int u,v;cin&gt;&gt;u&gt;&gt;v;        e[u].pb(v);        e[v].pb(u);    &#125;    dfs(root,1,0);    Log[1]=0,Log[2]=1;    for(int i=3;i&lt;=tot;i++)    Log[i]=Log[i/2]+1;    for(int i=1;i&lt;=tot;i++)f[i][0]=i;    for(int j=1;j&lt;=Log[tot];j++)    for(int i=1;i+(1&lt;&lt;j)-1&lt;=tot;i++)    if(depth[f[i][j-1]]&lt;depth[f[i+(1&lt;&lt;(j-1))][j-1]])f[i][j]=f[i][j-1];    else f[i][j]=f[i+(1&lt;&lt;(j-1))][j-1];    while(q--)&#123;        int u,v;cin&gt;&gt;u&gt;&gt;v;        int l=id[u],r=id[v];        if(l&gt;r)swap(l,r);    &#125;&#125;</code></pre><p>4.树链剖分$LCA$:预处理$O(n)$  单次查询$O(logn)$</p><p>暂定</p><p>树上$LCA$的几种常用模型：</p><p>1.动态维护树的直径</p><p>2.树上路径的交</p><p>3.树上路径的并</p>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E7%AC%94%E8%AE%B0/%E8%A1%A5%E9%A2%98/">补题</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E5%9B%BE%E8%AE%BA/">图论</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%A0%91%E8%AE%BA/">树论</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/LCA/">LCA</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/Tarjan/">Tarjan</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/st%E8%A1%A8/">st表</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/dfs/">dfs</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/bfs/">bfs</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/05/27/lca%E4%B8%8E%E6%A0%91%E4%B8%8A%EF%BC%88%E8%B7%AF%E5%BE%84%E4%BA%A4%E3%80%81%E5%B9%B6%EF%BC%8C%E7%9B%B4%E5%BE%84%EF%BC%89%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2023 Hubei Provincial Collegiate Programming Contest</title>
      <link>https://lifexoryoung.com.cn/2024/04/03/2023%20Hubei%20Provincial%20Collegiate%20Programming%20Contest/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/03/2023%20Hubei%20Provincial%20Collegiate%20Programming%20Contest/</guid>
      <pubDate>Wed, 03 Apr 2024 03:37:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/104337/problem/I&quot;&gt;Problem - I - step&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://codeforces.com/gym/104337/problem/I">Problem - I - step</a></p><span id="more"></span><p>题目：</p><p>给你 $n$ 个环，$i$ /th 环的长度是 $p_i(1\le i \le n)$ 。对于第 $i$ 个环， $p_i$ 的下一个位置是 $1$ 。一开始，每个环的 $1$ 位置都有一匹小马，而且小马的移动速度一天比一天快。</p><p>具体来说，小马第一天移动 $1$ 步，第二天移动 $2$ 步，以此类推。从形式上看，小马将在$k$ / $k \in \mathbb{N}$ 的第 $k$ 天移动 $k$ 步。</p><p>很明显，在某一天，所有的小马都会到达位置 $1$ 。现在，米库想知道最早的一天 $m$ ($0$ 除外)，所有的 $n$ 小马将到达位置 $1$ 。</p><p><strong>输入</strong></p><p>输入的第一行包含一个正整数 $n$（$1 \le n \le 10^5$），表示环的数量。</p><p>输入的第二行包含 $n$ 个正整数 $p_i$（$1 \le p_i \le 10^7$），表示每个环的长度。</p><p><strong>保证 $\{p_1, p_2, \ldots, p_n\}$ 的最小公倍数（LCM）不超过 $10^{18}$。</strong> 提醒一下，$\{p_1, p_2, \ldots, p_n\}$ 的最小公倍数（LCM）表示集合 $\{p_1, p_2, \ldots, p_n\}$ 中所有元素的最小公倍数。</p><p><strong>输出</strong></p><p>输出一个正整数，表示所有 $n$ 小马到达位置 $1$ 的最早日期。</p><p>分析：</p>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/codeforce/">codeforce</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/">扩展欧几里得</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/03/2023%20Hubei%20Provincial%20Collegiate%20Programming%20Contest/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Codeforces Round 942 (Div. 2)</title>
      <link>https://lifexoryoung.com.cn/2024/04/03/Codeforces%20Round%20942%20(Div.%202)/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/03/Codeforces%20Round%20942%20(Div.%202)/</guid>
      <pubDate>Wed, 03 Apr 2024 03:37:00 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;题目（Problem-D2-Reverse-Card-Hard-Version）-Codeforces）：&quot;&gt;&lt;a href=&quot;#题目（Problem-D2-Reverse-Card-Hard-Version）-Codeforces）：&quot; class=&quot;headerlink&quot; title=&quot;题目（Problem - D2. Reverse Card (Hard Version）- Codeforces）：&quot;&gt;&lt;/a&gt;题目（&lt;a href=&quot;https://codeforces.com/contest/1972/problem/D2&quot;&gt;Problem - D2. Reverse Card (Hard Version）- Codeforces&lt;/a&gt;）：&lt;/h3&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="题目（Problem-D2-Reverse-Card-Hard-Version）-Codeforces）："><a href="#题目（Problem-D2-Reverse-Card-Hard-Version）-Codeforces）：" class="headerlink" title="题目（Problem - D2. Reverse Card (Hard Version）- Codeforces）："></a>题目（<a href="https://codeforces.com/contest/1972/problem/D2">Problem - D2. Reverse Card (Hard Version）- Codeforces</a>）：</h3><span id="more"></span><h4 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h4><p>给你两个正整数 $n$ ， $m$ 。</p><p>请计算满足以下条件的有序数对 $(a, b)$的个数：</p><ul><li>$1\le a\le n$ , $1\le b\le m$ ;</li><li>$b \cdot \gcd(a,b)$ 是 $ a+b $ 的倍数。</li></ul><p><strong>输入</strong></p><p>每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ( $1\le t\le 10^4$ )。( $1\le t\le 10^4$ ).测试用例说明如下。</p><p>每个测试用例的第一行包含两个整数$n$ , $m$ ( $1\le n,m\le 2 \cdot 10^6$)。</p><p>保证所有测试用例中 $n$ 和 $m$ 的总和不超过 $2 \cdot 10^6$ 。</p><p><strong>输出</strong></p><p>为每个测试用例打印一个整数：有效配对的数量。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><script type="math/tex; mode=display">\begin{aligned}& b*gcd(a,b)=k*(a+b)\\&不妨设gcd(a,b)=d,则a=p*d,b=q*d\\&源式化为 (q+p)|qd=k\\&因为gcd(p,q)=gcd(p+q,q)=1\\&可得(q+p)|d=k\\&因为1\le q \le m \& q\le d ,则q \le \sqrt{m} ,同理p \le \sqrt{m}\\&则可以两层\sqrt{n},\sqrt{m},循环暴力枚举p,q ,用gcd(p,q)作为满足条件\\&对答案的贡献为ans+=\cfrac {min(\cfrac{n}{p},\cfrac{m}{q})}{(p+q)} 时间复杂度：O(\sqrt{n}·\sqrt{m}*logn)\\\end{aligned}</script><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">    void solve()&#123;        int n,m;cin&gt;&gt;n&gt;&gt;m;        int ans=0;        for(int i=1;i&lt;=n/i;i++)&#123;            for(int j=1;j&lt;=m/j;j++)&#123;                if(__gcd(i,j)==1)                ans+=min(n/i,m/j)/(i+j);            &#125;        &#125;    &#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/codeforce/">codeforce</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/">扩展欧几里得</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/03/Codeforces%20Round%20942%20(Div.%202)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site（2024武汉邀请赛）</title>
      <link>https://lifexoryoung.com.cn/2024/04/03/2024%20ICPC%20National%20Invitational%20Collegiate%20Programming%20Contest,%20Wuhan%20Site%EF%BC%882024%E6%AD%A6%E6%B1%89%E9%82%80%E8%AF%B7%E8%B5%9B%EF%BC%89/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/03/2024%20ICPC%20National%20Invitational%20Collegiate%20Programming%20Contest,%20Wuhan%20Site%EF%BC%882024%E6%AD%A6%E6%B1%89%E9%82%80%E8%AF%B7%E8%B5%9B%EF%BC%89/</guid>
      <pubDate>Wed, 03 Apr 2024 03:37:00 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;题目Problem-B-Countless-Me-Codeforces：&quot;&gt;&lt;a href=&quot;#题目Problem-B-Countless-Me-Codeforces：&quot; class=&quot;headerlink&quot; title=&quot;题目Problem - B. Countless Me- Codeforces：&quot;&gt;&lt;/a&gt;题目&lt;a href=&quot;https://codeforces.com/gym/105143/problem/B&quot;&gt;Problem - B. Countless Me- Codeforces&lt;/a&gt;：&lt;/h3&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="题目Problem-B-Countless-Me-Codeforces："><a href="#题目Problem-B-Countless-Me-Codeforces：" class="headerlink" title="题目Problem - B. Countless Me- Codeforces："></a>题目<a href="https://codeforces.com/gym/105143/problem/B">Problem - B. Countless Me- Codeforces</a>：</h3><span id="more"></span><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>假设最优的情况下，每个值为 $x_1$,$x_2$…$x_n$,则使给定序列变为最优值只需要一次，整个序列只需要n次，所以可以把序列变成任意序列。因为越$ | $越大,所以不难想到拆位并尽可能让高位置$0$。</p><p>我们不妨把所有值相加为$now$，从第$（1&lt;&lt;30）$ 开始高位往低位分析。设当前位为第$i$位，如果$now \le ((1&lt;&lt;i)-1)*n$ 那么可以当前位置0，否则我们尽量把当前位填更多$1$。（因为当前位置越多$1$,后面越容易置$0$,且因为当前位置$1$,拆成后面一定为偶数个$1$,在之后不能置$1$的情况下，一定会往前进位，那么现在置$1$不会更坏）</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">void solve()&#123;    int n,res=0;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        res+=x;    &#125;    int ans=0;    for(int i=30;i&gt;=0;i--)&#123;        int ver=((1ll&lt;&lt;i)-1)*n;        if(res&gt;ver)ans|=(1ll&lt;&lt;i),res-=min(n,res/(1ll&lt;&lt;i))*(1ll&lt;&lt;i);    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/codeforce/">codeforce</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/">扩展欧几里得</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/03/2024%20ICPC%20National%20Invitational%20Collegiate%20Programming%20Contest,%20Wuhan%20Site%EF%BC%882024%E6%AD%A6%E6%B1%89%E9%82%80%E8%AF%B7%E8%B5%9B%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2023icpc南京站补题</title>
      <link>https://lifexoryoung.com.cn/2024/04/01/2023icpc%E5%8D%97%E4%BA%AC%E7%AB%99%E8%A1%A5%E9%A2%98/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/01/2023icpc%E5%8D%97%E4%BA%AC%E7%AB%99%E8%A1%A5%E9%A2%98/</guid>
      <pubDate>Mon, 01 Apr 2024 07:56:00 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;vector&amp;lt;PII&amp;gt;e[N];
int n,m,c,minn,dist[N];
bool st[N];
void Dijkstra(int u)&amp;#123;
  </description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><pre><code class="lang-c++">vector&lt;PII&gt;e[N];int n,m,c,minn,dist[N];bool st[N];void Dijkstra(int u)&#123;    minn=1e18;    for(int i=1;i&lt;=n;i++)dist[i]=1e18,st[i]=0;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;    dist[u]=0;    q.push(&#123;dist[u],u&#125;);    while(q.size())&#123;        auto [dis,ver]=q.top();        q.pop();        if(st[ver])continue;        st[ver]=1;        for(auto [v,w]:e[ver])&#123;            if(v==u)minn=min(minn,dis+w);            if(st[v])continue;            if(dist[v]&gt;dis+w)&#123;                dist[v]=dis+w;                q.push(&#123;dist[v],v&#125;);            &#125;        &#125;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;    int ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,z;cin&gt;&gt;u&gt;&gt;v&gt;&gt;z;        e[u].pb(&#123;v,z&#125;);        if(z&lt;=c)ans=1;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        Dijkstra(i);        if(minn&lt;=c)&#123;ans=2;break;&#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E5%9B%BE%E8%AE%BA/">图论</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%9C%80%E5%B0%8F%E7%8E%AF/">最小环</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/Dijkstra/">Dijkstra</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/01/2023icpc%E5%8D%97%E4%BA%AC%E7%AB%99%E8%A1%A5%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>D.Birthday Gift</title>
      <link>https://lifexoryoung.com.cn/2024/04/01/Codeforces%20Round%20936%20(Div.%202)D.%20Birthday%20Gift/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/01/Codeforces%20Round%20936%20(Div.%202)D.%20Birthday%20Gift/</guid>
      <pubDate>Mon, 01 Apr 2024 07:56:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Problem-1946DBirthday-Gift&quot;&gt;&lt;a href=&quot;#Problem-1946DBirthday-Gift&quot; class=&quot;headerlink&quot; title=&quot;Problem - 1946DBirthday Gift&quot;&gt;&lt;/a&gt;&lt;a hre</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Problem-1946DBirthday-Gift"><a href="#Problem-1946DBirthday-Gift" class="headerlink" title="Problem - 1946DBirthday Gift"></a><a href="https://codeforces.com/problemset/problem/1946/D">Problem - 1946DBirthday Gift</a></h3><p>题面：</p><p>分析：</p><p>对于区间位运算容易想到拆位，对x进行从高位到低位拆位分析：</p><p>1.当$i$位为0时如果数组所有元素的第i位一共有奇数个1,那么无论怎么分配，总有一个段内有奇数个1，异或后结果为1，显然导致整体大于x。</p><p>2.当i位为0时如果有偶数个1，此时只能就近两两一组去保证异或为0还有组数最多，同时。</p><p>3.当i位为1时如果有奇数个1，此时不做任何处理，只能一段一个1.</p><p>4.当i位为1时如果有偶数个1，那么两两一组既能保证异或为0，还能保证组数最多，并且此时分组个数可以直接作为答案的一种取max，当然如果每个单独一组不做处理那么数组间异或结果为1，虽然此时不能当作答案，但是之后的数组的分配可能有更多的答案个数，所以也要把不做处理的情况传递下取去。</p><p>因为在第4个情况的时候，我们总是不做处理传递下去，并没有真正的处理x当前位相等的情况。所以我们对x进行+1，那么即使传递下去相等情况，那么也可以取答案。</p><p>代码：</p>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/01/Codeforces%20Round%20936%20(Div.%202)D.%20Birthday%20Gift/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>博客创建的流程</title>
      <link>https://lifexoryoung.com.cn/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Mon, 01 Apr 2024 07:56:00 GMT</pubDate>
      
      <description>&lt;p&gt;记录一下  $blog$ 创建的大体过程：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>记录一下  $blog$ 创建的大体过程：</p><span id="more"></span><p>跟着枫叶用的 $hexo+next$ 主题一步一步把第一代版本的博客建出来了</p><p>1.<a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a></p><img src="/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/myblog1.webp" class="" title="图片1"><p>其中有些步骤出问题或者因为他博客的小细节错误，在知乎下面的评论大部分都有提到。枫叶讲的都很详细我就不赘述了。</p><p>2.然后可以在<a href="https://hexo.io/themes/">Themes | Hexo</a>网站寻找自己想要的主题下载到$blog$的$themes$中替换即可。</p><img src="/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/myblog2.webp" class="" title="图片1"><p>第一个是$github$中的下载地址：点进去如下图的$download$即可</p><img src="/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/myblog3.webp" class="" title="图片1"><p>第二个是该主题的展示效果。</p><p>一般展示效果的首页第一个博客推文都会讲怎么去配置该主题</p><p>3.一些用的到的工具：</p><p><a href="https://try8.cn/tool/color/picker?eqid=f8d057810004bfbd0000000364759ea9">在线调色板  (try8.cn)</a>用于获取你想要的颜色，去修改主题</p><p><a href="https://www.likebizhi.com/tag/4k_page_1.html">高清4k图片_4k壁纸大全 - Like壁纸网 (likebizhi.com)</a>很多高清精品的壁纸，可以当背景等等</p><p><a href="https://fontawesome.com.cn/v5">图标库v5 - FontAwesome 字体图标中文Icon</a>用于博客的图标</p><p><a href="https://www.imhunk.com/cloudflare-tutorials/#title1">如何用CDN加速你的网站 - Cloudflare免费版详细使用教程 - Hunk (imhunk.com)</a>用cloudflare-CDN加速博客站点，cloudflare中在还有很多有用的优化，如下图的速度优化，读者可以自行探索</p><img src="/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/myblog4.webp" class="" title="图片1"><p><a href="https://www.erenship.com/posts/db37.html">Hexo 博客站点加速不完全指南 - Eren の 宇宙船 (erenship.com)</a>Vervel也可以加速，具体可以浏览这篇文章</p><p><a href="https://pagespeed.web.dev/analysis/https-lifexoryoung-com-cn/os1aw9wyc4?form_factor=desktop">PageSpeed Insights (web.dev)</a>测试你的网站登录速度，会给出分析报告</p>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0/">学习</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/hexo/">hexo</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/next/">next</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/vercal/">vercal</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/cloudfare/">cloudfare</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/cdn/">cdn</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/01/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>最小环-Dijkstra-Flyod</title>
      <link>https://lifexoryoung.com.cn/2024/04/01/%E6%9C%80%E5%B0%8F%E7%8E%AF/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/01/%E6%9C%80%E5%B0%8F%E7%8E%AF/</guid>
      <pubDate>Mon, 01 Apr 2024 07:56:00 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;2021CCPC桂林-E-Buy-and-Delete&quot;&gt;&lt;a href=&quot;#2021CCPC桂林-E-Buy-and-Delete&quot; class=&quot;headerlink&quot; title=&quot;2021CCPC桂林 E Buy and Delete &quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/gym/103409/problem/E&quot;&gt;2021CCPC桂林 E Buy and Delete &lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h4&gt;&lt;p&gt;爱丽丝和鲍勃正在有向图 $G$上玩游戏。在 $G$ 中有 $n$ 个顶点，标记为 $1,2,&#92;dots,n$ 。最初， $G$ 中没有边。爱丽丝会先从商店直接购买一些边，然后将它们添加到 $G$ 中。之后，鲍勃需要删除边，直到 $G$ 中没有边为止。在一轮删除中，鲍勃可以从 $G$ 中删除一个边子集 $S$ ，这样当只保留 $S$ 中的边时，图就是非循环的。请注意，爱丽丝可以什么也不买，在这种情况下，删除回合数为 $0$ 。&lt;/p&gt;
&lt;p&gt;商店中有 $m$ 条边。爱丽丝有 $c$美元，因此她要购买的边的总价不应超过 $c$ 。爱丽丝希望最大化删除回合数，而鲍勃希望最小化删除回合数。爱丽丝和鲍勃都将以最优方式下棋。请编写一个程序来预测删除回合数。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="2021CCPC桂林-E-Buy-and-Delete"><a href="#2021CCPC桂林-E-Buy-and-Delete" class="headerlink" title="2021CCPC桂林 E Buy and Delete "></a><a href="https://codeforces.com/gym/103409/problem/E">2021CCPC桂林 E Buy and Delete </a></h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>爱丽丝和鲍勃正在有向图 $G$上玩游戏。在 $G$ 中有 $n$ 个顶点，标记为 $1,2,\dots,n$ 。最初， $G$ 中没有边。爱丽丝会先从商店直接购买一些边，然后将它们添加到 $G$ 中。之后，鲍勃需要删除边，直到 $G$ 中没有边为止。在一轮删除中，鲍勃可以从 $G$ 中删除一个边子集 $S$ ，这样当只保留 $S$ 中的边时，图就是非循环的。请注意，爱丽丝可以什么也不买，在这种情况下，删除回合数为 $0$ 。</p><p>商店中有 $m$ 条边。爱丽丝有 $c$美元，因此她要购买的边的总价不应超过 $c$ 。爱丽丝希望最大化删除回合数，而鲍勃希望最小化删除回合数。爱丽丝和鲍勃都将以最优方式下棋。请编写一个程序来预测删除回合数。</p><span id="more"></span><p><strong>输入</strong></p><p>输入只包含一个案例。</p><p>输入的第一行包含三个整数 $n,m$ 和 $c$ ( $2 \leq n\leq 2000$ , $1\leq m \leq 5000$ , $1\leq c\leq 10^9$ )，分别表示 $G$ 中的顶点数、商店中的边数以及爱丽丝有多少美元。</p><p>在接下来的 $m$ 行中， $i$ 行 $(1 \le i \le m)$ 包含三个整数$u_i,v_i$ 和 $p_i$ ( $1\leq u_i,v_i\leq n$ , $1\leq p_i\le 100000$)，表示商店中的一条有向边。爱丽丝可以支付 $p_i$ 美元购买，并在 $G$ 中添加一条从顶点 $u_i$ 到顶点 $v_i$ 的边。</p><p><strong>输出</strong></p><p>打印一行，其中包含一个整数，表示删除轮数。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>无论几个环都会被删两轮，只有边没有环删一轮，还有一个边也买不起的情况为零轮。</p><p>$Dijkstra$求最小环即可时间复杂度为$O(n<em>m</em>logn)$ </p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">vector&lt;PII&gt;e[N];int n,m,c,minn,dist[N];bool st[N];void Dijkstra(int u)&#123;    minn=1e18;    for(int i=1;i&lt;=n;i++)dist[i]=1e18,st[i]=0;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;    dist[u]=0;    q.push(&#123;dist[u],u&#125;);    while(q.size())&#123;        auto [dis,ver]=q.top();        q.pop();        if(st[ver])continue;        st[ver]=1;        for(auto [v,w]:e[ver])&#123;            if(v==u)minn=min(minn,dis+w);            if(st[v])continue;            if(dist[v]&gt;dis+w)&#123;                dist[v]=dis+w;                q.push(&#123;dist[v],v&#125;);            &#125;        &#125;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;    int ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,z;cin&gt;&gt;u&gt;&gt;v&gt;&gt;z;        e[u].pb(&#123;v,z&#125;);        if(z&lt;=c)ans=1;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        Dijkstra(i);        if(minn&lt;=c)&#123;ans=2;break;&#125;    &#125;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E5%9B%BE%E8%AE%BA/">图论</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%9C%80%E5%B0%8F%E7%8E%AF/">最小环</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/Dijkstra/">Dijkstra</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/01/%E6%9C%80%E5%B0%8F%E7%8E%AF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>最小环/Dijkstra/Flyod</title>
      <link>https://lifexoryoung.com.cn/2024/04/01/%E6%89%A9%E6%AC%A7/</link>
      <guid>https://lifexoryoung.com.cn/2024/04/01/%E6%89%A9%E6%AC%A7/</guid>
      <pubDate>Mon, 01 Apr 2024 07:56:00 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;扩展欧几里得：&lt;/p&gt;
&lt;p&gt;对于任意整数 a,b ，求解 ax+by=m&lt;/p&gt;
&lt;p&gt;由裴蜀定理可知 ax+by=m 一定有解的充要条件为 gcd(a,b)|m &lt;/p&gt;
&lt;p&gt;所以对于解一般的 ax+by=m 不定方程，</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><p>扩展欧几里得：</p><p>对于任意整数 a,b ，求解 ax+by=m</p><p>由裴蜀定理可知 ax+by=m 一定有解的充要条件为 gcd(a,b)|m </p><p>所以对于解一般的 ax+by=m 不定方程，我们可以先证明ax+by=gcd(a,b),在扩展到一般域</p><p>假设一组解为 x1,y1 即ax1+by1=m:</p><p>因为gcd(a,b)=gcd(b,a%b) 即 bx2+(a%b)y2=ax1+by1;</p><p>其中 a%b=a-b<em>[a/b] 即 bx2+(a-b</em>[a/b])y2=ax1+by1</p><p>系数对称后可得：x1=y2,y1=x2-[a/b]y2 ;</p><p>我们考虑到在gcd(a,b)递归的最终结果为 b|a，则此时ax+b*0=gcd(a,0)=a ,x=1,y=0;</p><p>从此时往前递归并借用我们得到的x1,x2,y1,y2 的关系可得最终x1,y1</p><p>对于求逆元 ax_= 1(mod m)</p><p>即 ax+my =1 与上面同理可得解</p>]]></content:encoded>
      
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/">补题</category>
      
      <category domain="https://lifexoryoung.com.cn/categories/%E8%A1%A5%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</category>
      
      
      <category domain="https://lifexoryoung.com.cn/tags/%E5%9B%BE%E8%AE%BA/">图论</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%9C%80%E5%B0%8F%E7%8E%AF/">最小环</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</category>
      
      <category domain="https://lifexoryoung.com.cn/tags/Dijkstra/">Dijkstra</category>
      
      
      <comments>https://lifexoryoung.com.cn/2024/04/01/%E6%89%A9%E6%AC%A7/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
