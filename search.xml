<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>牛客周赛37</title>
    <url>/2024/03/20/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B37/</url>
    <content><![CDATA[<h3 id="题目：E-魔法之森的蘑菇"><a href="#题目：E-魔法之森的蘑菇" class="headerlink" title="题目：E-魔法之森的蘑菇"></a>题目：<a href="https://ac.nowcoder.com/acm/contest/77231/E">E-魔法之森的蘑菇</a></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一张图，起点为$S$终点为$T$，起初任意选择前进方向，除非遇到 $<em>$，否则不能更改方向，遇到 $</em>$ 可以选择朝向除返回刚刚位置的其他方向，$#$ 为障碍物，$.$ 为普通路径，求 $S$ $-$ $&gt;T$ 最短距离。</p>
<span id="more"></span>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>起初很容易考虑BFS，遇到 $*$ 就把三个方向全加进去，遇到 $.$ 就按原来方向走，同时把走过的点打上标记，通过bfs最短路属性记录最小答案。这个思路是没错的，但是我们之所以把走过的点打上标记，是因为我们已经保证这个点的所有状态已经加到队列中去。但是这个题一个点的所有状态并不是单纯走到这个点，而是包含了从四种方向走来的四种状态，比如假设一开始走到 $x$ 点为 $2$ 步，但是由于 $x$ 点为 $.$  ,它的这个方向并不能对最短答案有贡献，所以可能有一个更长的但是方向不一样的路径经过这个点，并且能对最短答案造成贡献。所以上述思路只需要改成走到一个点被打上标记只能是带有特定方向的，再取每个点距离最小值，本质上其实就是一个以四个方向形成的分层图最短路。</p>
<h4 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="lang-c++">int n, m, sx, sy, ex, ey, len[N][N][4], dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;;
bool st[N][N][4];
char g[N][N];
queue&lt;array&lt;int, 3&gt;&gt; q;
void solve()
&#123;
    while (q.size())
        q.pop();
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
        &#123;

            for (int k = 0; k &lt; 4; k++)
                st[i][j][k] = 0, len[i][j][k] = 1e18;
            ;
        &#125;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
        &#123;
            cin &gt;&gt; g[i][j];
            if (g[i][j] == &#39;S&#39;)
                sx = i, sy = j, g[i][j] = &#39;*&#39;;
            if (g[i][j] == &#39;T&#39;)
                ex = i, ey = j, g[i][j] = &#39;*&#39;;
        &#125;
    for (int i = 0; i &lt; 4; i++)
        st[sx][sy][i] = 1, len[sx][sy][i] = 0;
    for (int i = 0; i &lt; 4; i++)
    &#123;
        int t = sx + dx[i];
        int z = sy + dy[i];
        if (t &gt;= 1 &amp;&amp; t &lt;= n &amp;&amp; z &gt;= 1 &amp;&amp; z &lt;= m &amp;&amp; (g[t][z] == &#39;*&#39; || g[t][z] == &#39;.&#39;))
            st[t][z][i] = 1, q.push(&#123;t, z, i&#125;), len[t][z][i] = 1;
    &#125;

    while (q.size())
    &#123;
        auto [x, y, to] = q.front();
        q.pop();
        int t, z;
        // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;len[x][y]&lt;&lt;&quot;\n&quot;;
        if (x == ex &amp;&amp; y == ey)
            break;
        if (g[x][y] == &#39;.&#39;)
        &#123;
            t = x + dx[to], z = y + dy[to];
            if (t &gt;= 1 &amp;&amp; t &lt;= n &amp;&amp; z &gt;= 1 &amp;&amp; z &lt;= m &amp;&amp; (g[t][z] == &#39;*&#39; || g[t][z] == &#39;.&#39;) &amp;&amp; !st[t][z][to])
                q.push(&#123;t, z, to&#125;), len[t][z][to] = min(len[t][z][to], len[x][y][to] + 1), st[t][z][to] = 1;
        &#125;
        else if (g[x][y] == &#39;*&#39;)
        &#123;
            int tt;
            if (to == 0)
                tt = 1;
            else if (to == 1)
                tt = 0;
            else if (to == 2)
                tt = 3;
            else if (to == 3)
                tt = 2;
            for (int i = 0; i &lt; 4; i++)
            &#123;
                t = x + dx[i], z = y + dy[i];
                if (i != tt &amp;&amp; t &gt;= 1 &amp;&amp; t &lt;= n &amp;&amp; z &gt;= 1 &amp;&amp; z &lt;= m &amp;&amp; (g[t][z] == &#39;*&#39; || g[t][z] == &#39;.&#39;) &amp;&amp; !st[t][z][i])
                    q.push(&#123;t, z, i&#125;), len[t][z][i] = min(len[t][z][i], len[x][y][to] + 1), st[t][z][i] = 1;
            &#125;
        &#125;
    &#125;
    int ans = 1e18;
    for (int i = 0; i &lt; 4; i++)
        ans = min(ans, len[ex][ey][i]);
    if (ans != 1e18)
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    else
        cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;
&#125;
</code></pre>
<h3 id="题目：F-三途川的摆渡人"><a href="#题目：F-三途川的摆渡人" class="headerlink" title="题目：F-三途川的摆渡人_"></a>题目：<a href="https://ac.nowcoder.com/acm/contest/77231/F">F-三途川的摆渡人_</a></h3><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>$n$个数，每个数为$a_i$ ,$（0&lt;=a_i&lt;=127）$，求 $&amp;$ 成 $0$ 的得最少个数，不能输出 $-1$。</p>
<h4 id="题目分析：-1"><a href="#题目分析：-1" class="headerlink" title="题目分析："></a>题目分析：</h4><p>从 $&amp;$ 的性质去拆位贪心考虑显然太麻烦，但是 $&amp;$ 具有传递性可以状态转移。设 $dp[i]$$[a[i]&amp;j]$ 表示前i个物品，转移到 $a[i]&amp;j$ 的最小次数：</p>
<script type="math/tex; mode=display">
状态转移：dp[i][a[i]\&j]=\min(dp[i][a[i]\&j], dp[i-1][j]+1);</script><p>又因为相同的数$&amp;$，结果一定不为$0$，所以前$n$个数直接优化成扫$0$ $~$ $127$以内存在的值即可，而且只用到上一层所以直接滚动数组优化：</p>
<script type="math/tex; mode=display">
状态转移：dp[1][i\&j]=min(dp[1][i\&j],dp[0][j]+1);</script><h4 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="lang-c++">int dp[2][203],p[220];//滚动数组和记录0~127数存在与否的p
void solve()&#123;
    int n;cin&gt;&gt;n;
    memset(p,0,sizeof p);
    for(int i=1;i&lt;=n;i++)&#123;
        int x;cin&gt;&gt;x;
        p[x]++;
    &#125;
    memset(dp,0x3f,sizeof dp);
    for(int i=0;i&lt;=200;i++)&#123;
        if(p[i])&#123;
            dp[1][i]=1;//当前点选，并且没有比直接选当前点来组成当前点次数更小的了
            for(int j=0;j&lt;=200;j++)&#123;
                dp[1][i&amp;j]=min(dp[1][i&amp;j],dp[0][j]+1);//dp[1][i&amp;j]不选，后面为选的，取最小
            &#125;
        &#125;
        for(int j=0;j&lt;=200;j++)&#123;
            dp[0][j]=dp[1][j];//滚动赋值
        &#125;
    &#125;
    if(dp[0][0]&gt;n)cout&lt;&lt;-1&lt;&lt;&quot;\n&quot;;
    else cout&lt;&lt;n-dp[0][0]&lt;&lt;&quot;\n&quot;;//求得组成当前数最小个数，所以抛弃个数为n-dp[0][0]
&#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>分层图</tag>
        <tag>动态规划</tag>
        <tag>类背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title>lca与树上（路径交、并，直径）问题</title>
    <url>/2024/05/27/lca%E4%B8%8E%E6%A0%91%E4%B8%8A%EF%BC%88%E8%B7%AF%E5%BE%84%E4%BA%A4%E3%80%81%E5%B9%B6%EF%BC%8C%E7%9B%B4%E5%BE%84%EF%BC%89%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近的一些比赛中经常用到树上$lca$的常见模型，整理一下：</p>
<span id="more"></span>
<p>首先整理一下$LCA$的四种求法：</p>
<p>1.倍增$LCA$：预处理$O(nlogn)$  单次查询$O(logn)$</p>
<p>通过$bfs$预处理节点深度和$st$表倍增处理祖宗节点，在查询的时候用倍增先将两点跳到统一深度，再找同祖宗节点的最深节点</p>
<pre><code class="lang-c++">int n,depth[N],f[N][19];
vector&lt;int&gt;e[N];
void bfs(int root)&#123;
    memset(depth,0x3f,sizeof depth);
    depth[0]=0,depth[root]=1;//0为st表的哨兵
    queue&lt;int&gt;q;
    q.push(root);
    while(q.size())&#123;
        int ver=q.front();
        q.pop();
        for(auto &amp;to:e[ver])&#123;
            if(depth[to]&gt;depth[ver]+1)&#123;
                depth[to]=depth[ver]+1;
                f[to][0]=ver;
                for(int i=1;i&lt;=18;i++)
                f[to][i]=f[f[to][i-1]][i-1];
            &#125;
        &#125;
    &#125;
&#125;
int lca(int a,int b)&#123;
    if(depth[a]&lt;depth[b])swap(a,b);
    for(int i=18;i&gt;=0;i--)&#123;
        if(depth[f[a][i]]&lt;=depth[b])
        a=f[a][i];
    &#125;
    if(a==b)return a;
    for(int i=18;i&gt;=0;i--)&#123;
        if(f[a][i]!=f[b][i])
        a=f[a][i],b=f[b][i];
    &#125;
    return f[a][0];
&#125;
</code></pre>
<p>2.$Tarjan$离线$LCA$: 总体时间复杂度$O(n+q)$ ，$n$为节点 $q$为查询次数</p>
<p>暂定</p>
<p>3.在线$RMQLCA$：预处理$O(nlogn)$ 单次查询$O(1)$</p>
<p>通过$dfs$处理欧拉序及其深度，并保存每个节点第一次出现位置，通过$st$表维护区间深度最小值即可</p>
<pre><code class="lang-c++">
int n,q,root,depth[N&lt;&lt;1],f[N&lt;&lt;1][19],se[N&lt;&lt;1],tot,Log[N&lt;&lt;1],id[N];
vector&lt;int&gt;e[N];
void dfs(int u,int d,int fa)&#123;
    se[++tot]=u;
    id[u]=tot;
    depth[tot]=d;
    for(auto &amp;to:e[u])&#123;
        if(to==fa)continue;
        dfs(to,d+1,u);
        se[++tot]=u;
        depth[tot]=d;
    &#125;
&#125;
int lca(int l,int r)&#123;
    int k=Log[r-l+1];
    return depth[f[l][k]]&lt;depth[f[r-(1&lt;&lt;k)+1][k]]?
    se[f[l][k]]:se[f[r-(1&lt;&lt;k)+1][k]];
&#125;
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;q&gt;&gt;root;
    for(int i=1;i&lt;n;i++)&#123;
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        e[u].pb(v);
        e[v].pb(u);
    &#125;
    dfs(root,1,0);
    Log[1]=0,Log[2]=1;
    for(int i=3;i&lt;=tot;i++)
    Log[i]=Log[i/2]+1;

    for(int i=1;i&lt;=tot;i++)f[i][0]=i;

    for(int j=1;j&lt;=Log[tot];j++)
    for(int i=1;i+(1&lt;&lt;j)-1&lt;=tot;i++)
    if(depth[f[i][j-1]]&lt;depth[f[i+(1&lt;&lt;(j-1))][j-1]])f[i][j]=f[i][j-1];
    else f[i][j]=f[i+(1&lt;&lt;(j-1))][j-1];

    while(q--)&#123;
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        int l=id[u],r=id[v];
        if(l&gt;r)swap(l,r);
    &#125;
&#125;
</code></pre>
<p>4.树链剖分$LCA$:预处理$O(n)$  单次查询$O(logn)$</p>
<p>暂定</p>
<p>树上$LCA$的几种常用模型：</p>
<p>1.动态维护树的直径</p>
<p>2.树上路径的交</p>
<p>3.树上路径的并</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>补题</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树论</tag>
        <tag>LCA</tag>
        <tag>Tarjan</tag>
        <tag>st表</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>线段树</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 Hubei Provincial Collegiate Programming Contest</title>
    <url>/2024/04/03/2023%20Hubei%20Provincial%20Collegiate%20Programming%20Contest/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/104337/problem/I">Problem - I - step</a></p>
<span id="more"></span>
<p>题目：</p>
<p>给你 $n$ 个环，$i$ /th 环的长度是 $p_i(1\le i \le n)$ 。对于第 $i$ 个环， $p_i$ 的下一个位置是 $1$ 。一开始，每个环的 $1$ 位置都有一匹小马，而且小马的移动速度一天比一天快。</p>
<p>具体来说，小马第一天移动 $1$ 步，第二天移动 $2$ 步，以此类推。从形式上看，小马将在$k$ / $k \in \mathbb{N}$ 的第 $k$ 天移动 $k$ 步。</p>
<p>很明显，在某一天，所有的小马都会到达位置 $1$ 。现在，米库想知道最早的一天 $m$ ($0$ 除外)，所有的 $n$ 小马将到达位置 $1$ 。</p>
<p><strong>输入</strong></p>
<p>输入的第一行包含一个正整数 $n$（$1 \le n \le 10^5$），表示环的数量。</p>
<p>输入的第二行包含 $n$ 个正整数 $p_i$（$1 \le p_i \le 10^7$），表示每个环的长度。</p>
<p><strong>保证 $\{p_1, p_2, \ldots, p_n\}$ 的最小公倍数（LCM）不超过 $10^{18}$。</strong> 提醒一下，$\{p_1, p_2, \ldots, p_n\}$ 的最小公倍数（LCM）表示集合 $\{p_1, p_2, \ldots, p_n\}$ 中所有元素的最小公倍数。</p>
<p><strong>输出</strong></p>
<p>输出一个正整数，表示所有 $n$ 小马到达位置 $1$ 的最早日期。</p>
<p>分析：</p>
]]></content>
      <categories>
        <category>补题</category>
        <category>codeforce</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site（2024武汉邀请赛）</title>
    <url>/2024/04/03/2024%20ICPC%20National%20Invitational%20Collegiate%20Programming%20Contest,%20Wuhan%20Site%EF%BC%882024%E6%AD%A6%E6%B1%89%E9%82%80%E8%AF%B7%E8%B5%9B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目Problem-B-Countless-Me-Codeforces："><a href="#题目Problem-B-Countless-Me-Codeforces：" class="headerlink" title="题目Problem - B. Countless Me- Codeforces："></a>题目<a href="https://codeforces.com/gym/105143/problem/B">Problem - B. Countless Me- Codeforces</a>：</h3><span id="more"></span>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>假设最优的情况下，每个值为 $x_1$,$x_2$…$x_n$,则使给定序列变为最优值只需要一次，整个序列只需要n次，所以可以把序列变成任意序列。因为越$ | $越大,所以不难想到拆位并尽可能让高位置$0$。</p>
<p>我们不妨把所有值相加为$now$，从第$（1&lt;&lt;30）$ 开始高位往低位分析。设当前位为第$i$位，如果$now \le ((1&lt;&lt;i)-1)*n$ 那么可以当前位置0，否则我们尽量把当前位填更多$1$。（因为当前位置越多$1$,后面越容易置$0$,且因为当前位置$1$,拆成后面一定为偶数个$1$,在之后不能置$1$的情况下，一定会往前进位，那么现在置$1$不会更坏）</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">void solve()&#123;
    int n,res=0;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        int x;cin&gt;&gt;x;
        res+=x;
    &#125;
    int ans=0;
    for(int i=30;i&gt;=0;i--)&#123;
        int ver=((1ll&lt;&lt;i)-1)*n;
        if(res&gt;ver)ans|=(1ll&lt;&lt;i),res-=min(n,res/(1ll&lt;&lt;i))*(1ll&lt;&lt;i);
    &#125;
    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>codeforce</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 942 (Div. 2)</title>
    <url>/2024/04/03/Codeforces%20Round%20942%20(Div.%202)/</url>
    <content><![CDATA[<h3 id="题目（Problem-D2-Reverse-Card-Hard-Version）-Codeforces）："><a href="#题目（Problem-D2-Reverse-Card-Hard-Version）-Codeforces）：" class="headerlink" title="题目（Problem - D2. Reverse Card (Hard Version）- Codeforces）："></a>题目（<a href="https://codeforces.com/contest/1972/problem/D2">Problem - D2. Reverse Card (Hard Version）- Codeforces</a>）：</h3><span id="more"></span>
<h4 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h4><p>给你两个正整数 $n$ ， $m$ 。</p>
<p>请计算满足以下条件的有序数对 $(a, b)$的个数：</p>
<ul>
<li>$1\le a\le n$ , $1\le b\le m$ ;</li>
<li>$b \cdot \gcd(a,b)$ 是 $ a+b $ 的倍数。</li>
</ul>
<p><strong>输入</strong></p>
<p>每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ( $1\le t\le 10^4$ )。( $1\le t\le 10^4$ ).测试用例说明如下。</p>
<p>每个测试用例的第一行包含两个整数$n$ , $m$ ( $1\le n,m\le 2 \cdot 10^6$)。</p>
<p>保证所有测试用例中 $n$ 和 $m$ 的总和不超过 $2 \cdot 10^6$ 。</p>
<p><strong>输出</strong></p>
<p>为每个测试用例打印一个整数：有效配对的数量。</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><script type="math/tex; mode=display">
\begin{aligned}
& b*gcd(a,b)=k*(a+b)\\
&不妨设gcd(a,b)=d,则a=p*d,b=q*d\\
&源式化为 (q+p)|qd=k\\
&因为gcd(p,q)=gcd(p+q,q)=1\\
&可得(q+p)|d=k\\
&因为1\le q \le m \& q\le d ,则q \le \sqrt{m} ,同理p \le \sqrt{m}\\
&则可以两层\sqrt{n},\sqrt{m},循环暴力枚举p,q ,用gcd(p,q)作为满足条件\\
&对答案的贡献为ans+=\cfrac {min(\cfrac{n}{p},\cfrac{m}{q})}{(p+q)} 时间复杂度：O(\sqrt{n}·\sqrt{m}*logn)\\
\end{aligned}</script><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">    void solve()&#123;
        int n,m;cin&gt;&gt;n&gt;&gt;m;
        int ans=0;
        for(int i=1;i&lt;=n/i;i++)&#123;
            for(int j=1;j&lt;=m/j;j++)&#123;
                if(__gcd(i,j)==1)
                ans+=min(n/i,m/j)/(i+j);
            &#125;
        &#125;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>codeforce</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>2023icpc南京站补题</title>
    <url>/2024/04/01/2023icpc%E5%8D%97%E4%BA%AC%E7%AB%99%E8%A1%A5%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<pre><code class="lang-c++">vector&lt;PII&gt;e[N];
int n,m,c,minn,dist[N];
bool st[N];
void Dijkstra(int u)&#123;
    minn=1e18;
    for(int i=1;i&lt;=n;i++)dist[i]=1e18,st[i]=0;
    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;
    dist[u]=0;
    q.push(&#123;dist[u],u&#125;);
    while(q.size())&#123;
        auto [dis,ver]=q.top();
        q.pop();
        if(st[ver])continue;
        st[ver]=1;
        for(auto [v,w]:e[ver])&#123;
            if(v==u)minn=min(minn,dis+w);
            if(st[v])continue;
            if(dist[v]&gt;dis+w)&#123;
                dist[v]=dis+w;
                q.push(&#123;dist[v],v&#125;);
            &#125;
        &#125;
    &#125;
&#125;
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;
    int ans=0;
    for(int i=1;i&lt;=m;i++)&#123;
        int u,v,z;cin&gt;&gt;u&gt;&gt;v&gt;&gt;z;
        e[u].pb(&#123;v,z&#125;);
        if(z&lt;=c)ans=1;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        Dijkstra(i);
        if(minn&lt;=c)&#123;ans=2;break;&#125;
    &#125;
    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小环</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>D.Birthday Gift</title>
    <url>/2024/04/01/Codeforces%20Round%20936%20(Div.%202)D.%20Birthday%20Gift/</url>
    <content><![CDATA[<h3 id="Problem-1946DBirthday-Gift"><a href="#Problem-1946DBirthday-Gift" class="headerlink" title="Problem - 1946DBirthday Gift"></a><a href="https://codeforces.com/problemset/problem/1946/D">Problem - 1946DBirthday Gift</a></h3><p>题面：</p>
<p>分析：</p>
<p>对于区间位运算容易想到拆位，对x进行从高位到低位拆位分析：</p>
<p>1.当$i$位为0时如果数组所有元素的第i位一共有奇数个1,那么无论怎么分配，总有一个段内有奇数个1，异或后结果为1，显然导致整体大于x。</p>
<p>2.当i位为0时如果有偶数个1，此时只能就近两两一组去保证异或为0还有组数最多，同时。</p>
<p>3.当i位为1时如果有奇数个1，此时不做任何处理，只能一段一个1.</p>
<p>4.当i位为1时如果有偶数个1，那么两两一组既能保证异或为0，还能保证组数最多，并且此时分组个数可以直接作为答案的一种取max，当然如果每个单独一组不做处理那么数组间异或结果为1，虽然此时不能当作答案，但是之后的数组的分配可能有更多的答案个数，所以也要把不做处理的情况传递下取去。</p>
<p>因为在第4个情况的时候，我们总是不做处理传递下去，并没有真正的处理x当前位相等的情况。所以我们对x进行+1，那么即使传递下去相等情况，那么也可以取答案。</p>
<p>代码：</p>
]]></content>
      <categories>
        <category>补题</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>最小环/Dijkstra/Flyod</title>
    <url>/2024/04/01/%E6%89%A9%E6%AC%A7/</url>
    <content><![CDATA[<span id="more"></span>
<p>扩展欧几里得：</p>
<p>对于任意整数 a,b ，求解 ax+by=m</p>
<p>由裴蜀定理可知 ax+by=m 一定有解的充要条件为 gcd(a,b)|m </p>
<p>所以对于解一般的 ax+by=m 不定方程，我们可以先证明ax+by=gcd(a,b),在扩展到一般域</p>
<p>假设一组解为 x1,y1 即ax1+by1=m:</p>
<p>因为gcd(a,b)=gcd(b,a%b) 即 bx2+(a%b)y2=ax1+by1;</p>
<p>其中 a%b=a-b<em>[a/b] 即 bx2+(a-b</em>[a/b])y2=ax1+by1</p>
<p>系数对称后可得：x1=y2,y1=x2-[a/b]y2 ;</p>
<p>我们考虑到在gcd(a,b)递归的最终结果为 b|a，则此时ax+b*0=gcd(a,0)=a ,x=1,y=0;</p>
<p>从此时往前递归并借用我们得到的x1,x2,y1,y2 的关系可得最终x1,y1</p>
<p>对于求逆元 ax_= 1(mod m)</p>
<p>即 ax+my =1 与上面同理可得解</p>
]]></content>
      <categories>
        <category>补题</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小环</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>最小环/Dijkstra/Flyod</title>
    <url>/2024/04/01/%E6%9C%80%E5%B0%8F%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="2021CCPC桂林-E-Buy-and-Delete"><a href="#2021CCPC桂林-E-Buy-and-Delete" class="headerlink" title="2021CCPC桂林 E Buy and Delete "></a><a href="https://codeforces.com/gym/103409/problem/E">2021CCPC桂林 E Buy and Delete </a></h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>爱丽丝和鲍勃正在有向图 $G$上玩游戏。在 $G$ 中有 $n$ 个顶点，标记为 $1,2,\dots,n$ 。最初， $G$ 中没有边。爱丽丝会先从商店直接购买一些边，然后将它们添加到 $G$ 中。之后，鲍勃需要删除边，直到 $G$ 中没有边为止。在一轮删除中，鲍勃可以从 $G$ 中删除一个边子集 $S$ ，这样当只保留 $S$ 中的边时，图就是非循环的。请注意，爱丽丝可以什么也不买，在这种情况下，删除回合数为 $0$ 。</p>
<p>商店中有 $m$ 条边。爱丽丝有 $c$美元，因此她要购买的边的总价不应超过 $c$ 。爱丽丝希望最大化删除回合数，而鲍勃希望最小化删除回合数。爱丽丝和鲍勃都将以最优方式下棋。请编写一个程序来预测删除回合数。</p>
<span id="more"></span>
<p><strong>输入</strong></p>
<p>输入只包含一个案例。</p>
<p>输入的第一行包含三个整数 $n,m$ 和 $c$ ( $2 \leq n\leq 2000$ , $1\leq m \leq 5000$ , $1\leq c\leq 10^9$ )，分别表示 $G$ 中的顶点数、商店中的边数以及爱丽丝有多少美元。</p>
<p>在接下来的 $m$ 行中， $i$ 行 $(1 \le i \le m)$ 包含三个整数$u_i,v_i$ 和 $p_i$ ( $1\leq u_i,v_i\leq n$ , $1\leq p_i\le 100000$)，表示商店中的一条有向边。爱丽丝可以支付 $p_i$ 美元购买，并在 $G$ 中添加一条从顶点 $u_i$ 到顶点 $v_i$ 的边。</p>
<p><strong>输出</strong></p>
<p>打印一行，其中包含一个整数，表示删除轮数。</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>无论几个环都会被删两轮，只有边没有环删一轮，还有一个边也买不起的情况为零轮。</p>
<p>$Dijkstra$求最小环即可时间复杂度为$O(n<em>m</em>logn)$ </p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-c++">vector&lt;PII&gt;e[N];
int n,m,c,minn,dist[N];
bool st[N];
void Dijkstra(int u)&#123;
    minn=1e18;
    for(int i=1;i&lt;=n;i++)dist[i]=1e18,st[i]=0;
    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;
    dist[u]=0;
    q.push(&#123;dist[u],u&#125;);
    while(q.size())&#123;
        auto [dis,ver]=q.top();
        q.pop();
        if(st[ver])continue;
        st[ver]=1;
        for(auto [v,w]:e[ver])&#123;
            if(v==u)minn=min(minn,dis+w);
            if(st[v])continue;
            if(dist[v]&gt;dis+w)&#123;
                dist[v]=dis+w;
                q.push(&#123;dist[v],v&#125;);
            &#125;
        &#125;
    &#125;
&#125;
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;
    int ans=0;
    for(int i=1;i&lt;=m;i++)&#123;
        int u,v,z;cin&gt;&gt;u&gt;&gt;v&gt;&gt;z;
        e[u].pb(&#123;v,z&#125;);
        if(z&lt;=c)ans=1;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        Dijkstra(i);
        if(minn&lt;=c)&#123;ans=2;break;&#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小环</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 USP-ICMC</title>
    <url>/2024/03/22/2016%20USP-ICMC/</url>
    <content><![CDATA[<h3 id="Problem-B-Martian-Sunrise贪心"><a href="#Problem-B-Martian-Sunrise贪心" class="headerlink" title="Problem - B - Martian Sunrise贪心"></a><a href="https://codeforces.com/gym/101063/problem/B">Problem - B - Martian Sunrise贪心</a></h3><span id="more"></span>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你$m$行音调，每行音调有$7$个元素，给你一行目标音调$n$ , 每次可以从$m$行任选两行,作为你的元素集合去匹配目标音调，求最少多少次完成匹配。$（1 \le m \le 16，1 \le n \le 1e4）$</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>所有选择的方案总共$m*(m-1)/2$，乘上总元素大约$3000$，然后直接从第一个目标音调的元素枚举到$n$，同时枚举所有现存的包含当前元素的集合，同时去除不包含的，如何此时没有任何一个集合满足，则重新枚举所有集合并且答案数$++$。这里有个贪心正确性：取匹配目标元素最长的集合并不会让总集合数变多。时间复杂度大约$3e7$左右。</p>
<h4 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="lang-C++">map&lt;string, int&gt; mp;
int cnt;
set&lt;int&gt; b[300];
bool st[300];
void solve()
&#123;
    int m;
    cin &gt;&gt; m;
    vector&lt;int&gt; v[m];
    for (int i = 0; i &lt; m; i++)
    &#123;
        for (int j = 0; j &lt; 7; j++)
        &#123;
            string s;
            cin &gt;&gt; s;
            if (!mp[s])
            mp[s] = ++cnt;
            v[i].pb(mp[s]);
        &#125;
    &#125;

    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for (auto &amp;x : a)
    &#123;
        string s;
        cin &gt;&gt; s;
        x = mp[s];
    &#125;

    int idx = 0;
    if (m == 1)
    &#123;
        for (auto &amp;x : v[0])
            b[idx].insert(x);
        idx++;
    &#125;

    for (int i = 0; i &lt; m; i++)
    &#123;
        for (int j = i + 1; j &lt; m; j++)
        &#123;
            for (auto &amp;x : v[i])
                b[idx].insert(x);
            for (auto &amp;x : v[j])
                b[idx].insert(x);
            idx++;
        &#125;
    &#125;

    memset(st, 0, sizeof st);
    int num = idx, ans = 1;
    for (int i = 0; i &lt; n; i++)
    &#123;
        for (int j = 0; j &lt; idx; j++)
        &#123;
            if (!st[j] &amp;&amp; b[j].find(a[i]) == b[j].end())
                num--, st[j] = 1;
            if (!num)
            &#123;
                i--;
                break;
            &#125;
        &#125;
        if (!num)
            num = idx, ans++, memset(st, 0, sizeof st);
    &#125;

    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
&#125;
</code></pre>
<h3 id="Problem-I-Lazy-Painting-DFS-SET-stl"><a href="#Problem-I-Lazy-Painting-DFS-SET-stl" class="headerlink" title="Problem - I. Lazy Painting/DFS/SET(stl)"></a><a href="https://codeforces.com/gym/101063/problem/I">Problem - I. Lazy Painting/DFS/SET(stl)</a></h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实验室地板可以表示为一个 $N$ 行、$M$ 列的矩阵，总共有 $N \times M$ 块瓷砖。指令是以矩形区域为单位进行涂漆，每个矩形的高度为 $H$，宽度为 $W$，且这些矩形可以重叠。每次指令后，需要计算还有多少瓷砖未涂漆。</p>
<p>马加里达负责执行指令，她会检查矩形的左边界，如果左侧边框中的瓷砖都已经涂漆，她会跳过该矩形。如果有未涂漆的瓷砖，她会将从左侧边框可到达的所有未涂漆的瓷砖进行涂漆。如果只有矩形内的未涂漆瓷砖可以到达某个瓷砖，那么这个瓷砖也会被涂漆。</p>
<p><strong>输入</strong></p>
<p>第一行包含五个整数 $N$、$M$ $(1 ≤ N, M ≤ 10^5$ 和 $1 ≤ N <em> M ≤ 3 </em> 10^6)$、$H$、$W$ $(1 ≤ H ≤ N$， $1 ≤ W ≤ M)$ 和 $Q$ $(1 ≤ Q ≤ 10^5)$. 然后是 $Q$ 行. 第 $i$ 行包含两个整数 $r_i$ 和 $c_i$ $(1 ≤ r_i ≤ N - H + 1$， $1 ≤ c_i ≤ M - W + 1)$—要绘制的矩形区域的左上平铺. 研究实验室最左边最上面的瓦片是 $(1, 1)$.</p>
<p><strong>输出</strong></p>
<p>每次指令过后有多少未覆盖的瓷片.</p>
<h4 id="题目分析：-1"><a href="#题目分析：-1" class="headerlink" title="题目分析："></a>题目分析：</h4><p>因为是检查左边界，用$set$记录每列还有哪些没有被覆盖。当执行命令的时候二分查找还存在的，加到队列中进行$DFS/BFS$覆盖即可，同时维护答案—。因为整个询问 $q$ 次的时候，矩阵只会被访问一次 ，每次访问的时候set删除 $\log n$，所以总复杂度约为 $O((Q+N \times M) \log n)$.</p>
<h4 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="lang-c++">int n, m, h, w, Q, ans, dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;;
set&lt;int&gt; s[N];
queue&lt;PII&gt; q;
bitset&lt;M&gt; st;
void bfs(int u, int v)
    &#123;
        int nn = u + h - 1, mm = v + w - 1;
        set&lt;int&gt;::iterator it = s[v].lower_bound(u);
        // cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;*it&lt;&lt;&quot; &quot;&lt;&lt;nn&lt;&lt;&quot; &quot;&lt;&lt;mm&lt;&lt;&quot;\n&quot;;
        while (*it &lt;= nn)
        &#123;
            q.push(&#123;*it, v&#125;);
            // cout&lt;&lt;*it&lt;&lt;&quot;\n&quot;;
            st[(*it - 1) * m + v] = 1;
            it++, ans--;
        &#125;
        // cout&lt;&lt;nn&lt;&lt;&quot;#&quot;&lt;&lt;mm&lt;&lt;&quot;#&quot;&lt;&lt;q.size()&lt;&lt;&quot;\n&quot;;
        while (q.size())
        &#123;
            auto [xx, yy] = q.front();
            q.pop();
            s[yy].erase(xx);
            for (int i = 0; i &lt; 4; i++)
            &#123;
                int t = xx + dx[i];
                int z = yy + dy[i];
                if (t &gt;= u &amp;&amp; t &lt;= nn &amp;&amp; z &gt;= v &amp;&amp; z &lt;= mm &amp;&amp; st[(t - 1) * m + z] == 0)
                &#123;
                    st[(t - 1) * m + z] = 1;
                    q.push(&#123;t, z&#125;);
                    ans--;
                &#125;
            &#125;
        &#125;
&#125;
void solve()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; w &gt;&gt; Q;
    ans = n * m;
    for (int i = 1; i &lt;= n+1; i++)
    &#123;
        for (int j = 1; j &lt;= m; j++)
            s[j].insert(i);
    &#125;

    while (Q--)
    &#123;
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        bfs(x, y);
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>codeforce</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>409选拔赛补题</title>
    <url>/2024/03/22/409%E9%80%89%E6%8B%94%E8%B5%9B%E8%A1%A5%E9%A2%98%20/</url>
    <content><![CDATA[<h3 id="Problem-A-Find-a-Number同余最短路-建图"><a href="#Problem-A-Find-a-Number同余最短路-建图" class="headerlink" title="Problem - A -  Find a Number同余最短路/建图"></a><a href="https://codeforces.com/contest/1070/problem/A">Problem - A -  Find a Number同余最短路/建图</a></h3><span id="more"></span>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你两个正整数 $d$ 和 $s$ 。求能被 $d$ 整除且其数位之和等于 $s$ 的最小正整数 $n$ 。</p>
<p><strong>输入</strong></p>
<p>第一行包含两个正整数 $d$ 和 $s$ （ $1 \le d \le 500, 1 \le s \le 5000$ ），用空格隔开。</p>
<p><strong>输出</strong></p>
<p>打印所需的数字，如果不存在，则打印 （-1）。</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>有一个性质：假设一个数为 $x$，则$x%mod$后再添加任何数位都不会影响已经$mod$掉的。（因为再加上任何数位，已经 $mod$ 掉的只会$*$ $10^x$）</p>
<p>所以用$dis[模数]$ $[数位之和]$作为点，建图跑最短路，顺便维护一下当前点从哪一个点转移过来的记录路径即可。</p>
<h4 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="lang-c++">queue&lt;array&lt;int, 2&gt;&gt; q;
bitset&lt;1&gt; st[N][M];
int s, d;
struct node
&#123;
    short x, y, z;
&#125; path[N][M];
stack&lt;int&gt; stk;
void solve()
&#123;
    cin &gt;&gt; s &gt;&gt; d;
    st[0][0] = 1;
    q.push(&#123;0, 0&#125;);
    path[0][0] = &#123;-1, -1, -1&#125;;
    while (q.size())
    &#123;
        auto [mod, sum] = q.front();
        q.pop();
        for (int i = 0; i &lt;= 9; i++)
        &#123;
            int ver = (mod * 10 + i) % s, su = sum + i;
            if (su &lt;= d &amp;&amp; st[ver][su] == 0)
                q.push(&#123;ver, su&#125;), st[ver][su] = 1, path[ver][su] = &#123;mod, sum, i&#125;;
        &#125;
    &#125;
    if (st[0][d] == 0)
    &#123;
        cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;
        return;
    &#125;
    s = 0;
    while (path[s][d].x != -1)
    &#123;
        auto [x, y, z] = path[s][d];
        stk.push(z);
        s = x, d = y;
    &#125;
    while (stk.size())
    &#123;
        cout &lt;&lt; stk.top();
        stk.pop();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>补题</category>
        <category>codeforce</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>同余最短路</tag>
      </tags>
  </entry>
</search>
